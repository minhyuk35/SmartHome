SmartHome (Java 폴더) 발표 대본

0) 오프닝(10초)
- “제가 발표할 Java 폴더는 ‘PC 컨트롤 센터’ 역할입니다. (1) GUI로 상태를 보여주고, (2) TCP 서버 3개로 외부 모듈(Python/센서/Jupyter 등)과 메시지를 주고받습니다.”

1) 실행/구동 순서(20초)
- `compile_utf8.bat` : `javac -encoding UTF-8 *.java`로 컴파일(한글 깨짐 방지)
- `Main.java` 실행: Java가 아래 포트에 서버로 대기하고, GUI 창이 뜹니다.
  - 명령(Command) 서버: 39186
  - 센서(Sensor) 서버: 39187
  - 도어락 이벤트(Door Event) 서버: 39189

2) 포트/메시지 규칙(핵심)(40초)
- 공통: “한 줄 = 한 메시지” (Java 쪽은 `readLine()` 기반이라 `\n`으로 끝나야 합니다)
- 39186 (명령, `TcpServer.java`)
  - 방향: 외부(Python/기타 클라이언트) ↔ Java 서버
  - 역할: 명령을 받으면 GUI에 알리고(콜백), 다른 클라이언트들에게 브로드캐스트합니다.
  - 예시 명령: `LED_ON`, `LED_OFF`, `FAN_ON`, `FAN_OFF`, `RGB_ON`, `RGB_OFF`, `RGB_SET r g b`, `REQ_FACE_UNLOCK`, `REGISTER_FACE`
  - 참고: `UNLOCK/LOCKED/...` 같은 “도어 상태 이벤트”도 이 포트로 들어올 수 있고, GUI가 별도로 도어 이벤트로 처리합니다.
- 39187 (센서 피드, `SensorTcpServer.java`)
  - 방향: 센서/노트북(Jupyter 등) → Java 서버 → GUI 갱신
  - 메시지 포맷(예): `SENSOR GAS=123 METHAN=1 TEMP=25.50 HUMI=36.70 PM1=7 PM25=5 PM10=8 PIR=0`
  - Java는 여기서 GAS/HUMI/PM10/PIR를 뽑아 GUI에 전달합니다.
- 39189 (도어 이벤트, `DoorlockServer.java`)
  - 방향: 도어락/외부 모듈 → Java 서버(수신) → GUI 갱신(+다른 클라이언트에게 브로드캐스트)
  - 예시 이벤트: `LOCKED`, `UNLOCKED`, `ALERT_FAIL_3` (GUI는 `UNLOCK`도 `UNLOCKED`로 정규화)
- 40191 (음성 트리거, `SmartHomeGUI.java`)
  - 방향: GUI → (localhost) Python 음성 서버
  - 메시지: `START_RECORDING` / `STOP_RECORDING` (버튼 토글)

3) 전체 연결 흐름(그림으로 1번만)(30초)
  [센서/노트북] --(SENSOR...)-> (39187 SensorTcpServer) ---> GUI 표시

  [GUI 버튼] --(LED_ON 등)-> (39186 TcpServer) --브로드캐스트--> [Python/기타 클라이언트]
                                 |
                                 +--> GUI도 onCommand 콜백으로 즉시 화면 업데이트

  [도어락/외부] --(LOCKED/UNLOCKED)-> (39189 DoorlockServer) ---> GUI 표시 (+브로드캐스트)

  [GUI 음성버튼] --(START/STOP)-> (40191 Python Voice Server) -> STT/명령추출 -> (39186으로 다시 명령 전송)

4) 파일별로 “뭘 담당하는지”만 딱 정리(각 20초)

4-1) `Main.java`
- 실행 시작점(entry point).
- 포트 번호를 정하고(`39186/39187/39189`), 서버 3개와 GUI 1개를 생성해서 연결합니다.
- 서버들을 백그라운드(스레드)로 실행합니다(그래서 GUI가 멈추지 않음).

4-2) `TcpServer.java` (명령 허브)
- 여러 클라이언트를 동시에 받는 TCP 서버입니다.
- 클라이언트가 한 줄을 보내면:
  1) `CommandListener.onCommand(cmd)`로 GUI에 “명령 들어왔어”라고 알려주고
  2) 같은 명령을 다른 클라이언트들에게 브로드캐스트합니다.
- GUI에서 버튼 누를 때는 `sendCommand()`로 “모든 클라이언트에게 명령 전파”를 합니다.

4-3) `SensorTcpServer.java` (센서 수신)
- 센서값은 “SENSOR로 시작하는 한 줄 문자열”로 들어옵니다.
- `parseSensorPacket()`에서 `KEY=VALUE` 형태를 파싱하고, `SensorListener` 콜백으로 GUI에 전달합니다.
- 연결이 끊겨도 다시 `accept()`로 재연결을 받도록 되어 있습니다.

4-4) `DoorlockServer.java` (도어 이벤트 수신/브로드캐스트)
- 도어락 상태/이벤트를 받는 멀티클라이언트 TCP 서버입니다.
- 들어온 이벤트를 GUI로 넘기고(`DoorlockListener`), 동시에 다른 클라이언트에게도 브로드캐스트합니다.

4-5) `SmartHomeGUI.java` (화면 + 사용자 입력 + 자동 로직)
- 화면 구성: 센서 카드(가스/습도표시/미세먼지/모션/PIR/도어락/조명상태) + 제어 버튼(LED/FAN/LIGHT/RGB) + 음성 버튼 + RGB 슬라이더.
- 버튼 → 메시지 송신:
  - 예) “LED ON” 클릭 → `commandServer.sendCommand("LED_ON")`
  - 음성 버튼 토글 → `127.0.0.1:40191`로 `START_RECORDING`/`STOP_RECORDING` 한 줄 전송
- 메시지 수신 → 화면 갱신:
  - 센서: `sensorServer.addSensorListener(...)`로 값 들어오면 Swing 스레드에서 라벨 업데이트
  - 도어: `doorlockServer.addDoorlockListener(...)`로 `LOCKED/UNLOCKED/ALERT...` 들어오면 표시 업데이트
  - 명령: `commandServer.addCommandListener(...)`로 `LED_ON`, `RGB_SET...` 같은 명령이 들어오면 조명 상태 표시 업데이트
- “보안/자동화” 포인트(발표에서 강조하면 좋음):
  - 처음에는(= `UNLOCKED`를 한 번이라도 받기 전까지) 조명/팬/RGB 같은 제어를 비활성화(gated)하고,
  - `UNLOCKED` 이벤트가 한 번 들어오면 이후 제어가 활성화됩니다(현재 코드는 다시 `LOCKED`가 와도 재비활성화는 하지 않음).
  - PIR이 감지되면(`pir==1`) 자동으로 `REQ_FACE_UNLOCK`을 브로드캐스트해서 얼굴 인증을 유도합니다(쿨다운 5초).

4-6) `compile_utf8.bat`
- 윈도우에서 한글이 깨질 때 가장 먼저 확인할 파일입니다(UTF-8로 컴파일).

5) “메시지가 실제로 어떻게 동작하나” 시나리오 3개(각 20~30초)

시나리오 A) LED 켜기
- (사용자) GUI에서 “LED ON” 클릭
- (Java) `TcpServer.sendCommand("LED_ON")` → 39186에 연결된 모든 클라이언트로 브로드캐스트
- (외부) Python/장치가 `LED_ON`을 받아 실제 LED를 켬

시나리오 B) PIR 감지 → 자동 얼굴인증 유도
- (센서) `... PIR=1` 포함된 `SENSOR ...` 패킷 전송
- (Java) GUI가 PIR을 “DETECTED”로 표시 + 잠금 상태면 `REQ_FACE_UNLOCK`을 39186으로 브로드캐스트
- (외부) Python이 `REQ_FACE_UNLOCK`을 받으면 얼굴 인식을 수행하고, 성공하면 다시 `UNLOCK`을 39186으로 전송
- (Java) GUI가 `UNLOCK`/`UNLOCKED`를 받으면 잠금 표시를 초록색으로 바꾸고, 제어 버튼들을 활성화

시나리오 C) 음성 제어
- (사용자) GUI에서 “Voice Command” 버튼 클릭 → `START_RECORDING`을 40191로 전송
- (사용자) 다시 버튼 클릭 → `STOP_RECORDING` 전송
- (외부) Python 음성 서버가 STT 후 “불 켜” 같은 문장을 `LED_ON`으로 매핑해 39186으로 전송
- (Java) GUI는 들어온 명령을 받아 조명 상태를 “ON/RGB/OFF”로 갱신

6) 마무리 멘트(10초)
- “정리하면 Java는 UI + TCP 메시지 허브이고, 외부(Python/센서/Jupyter)가 이 포트로 접속해서 한 줄짜리 명령/이벤트/센서 데이터를 주고받는 구조입니다.”
